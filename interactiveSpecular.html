<html lang="eng">
<head>
	<title>Baked Lighting</title>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/CubeMapFlatView.js"></script>

<!-- VERTEX SHADER BEGIN --> 
	<script type="x-shader/x-vertex" id="vertexShader">

	attribute vec4 tangent;
	varying vec3 pos, view;
	varying mat3 tbnMatrix;
	varying vec2 vUv;
	uniform vec2 repeatUV;
	uniform float bumpiness;

	mat3 m3( mat4 mIn ) {

		mat3 mOut;

		mOut[ 0 ][ 0 ] = mIn[ 0 ][ 0 ];
		mOut[ 0 ][ 1 ] = mIn[ 0 ][ 1 ];
		mOut[ 0 ][ 2 ] = mIn[ 0 ][ 2 ];

		mOut[ 1 ][ 0 ] = mIn[ 1 ][ 0 ];
		mOut[ 1 ][ 1 ] = mIn[ 1 ][ 1 ];
		mOut[ 1 ][ 2 ] = mIn[ 1 ][ 2 ];

		mOut[ 2 ][ 0 ] = mIn[ 2 ][ 0 ];
		mOut[ 2 ][ 1 ] = mIn[ 2 ][ 1 ];
		mOut[ 2 ][ 2 ] = mIn[ 2 ][ 2 ];

		return mOut;
	}

	void main()  {

		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		pos = vec3(modelMatrix * vec4( position, 1. ) );

		if( bumpiness != 0. ){
			vec3 correctedTangent = m3( modelMatrix ) * tangent.xyz;
			vec3 binormal = m3( modelMatrix ) * cross(normal, correctedTangent.xyz );
			vec3 normal = m3( modelMatrix ) * normal;

			tbnMatrix = mat3( normalize( correctedTangent ), normalize( binormal ), normalize( normal ) );
		} else {
			tbnMatrix = mat3( normal, normal, normal );
		}

		view = pos - cameraPosition;

		vUv = uv * repeatUV;

	}

	</script>

<!-- VERTEX SHADER END --> 


<!-- FRAGMENT SHADER BEGIN --> 

	<script type="x-shader/x-vertex" id="fragmentShader">
	#ifdef TEXTURELOD
	#extension GL_EXT_shader_texture_lod : enable
	#endif
	varying vec3 pos, view;
	varying vec2 vUv;
	varying mat3 tbnMatrix;
	uniform samplerCube envMap;
	uniform sampler2D normalMap;
	uniform sampler2D detailNormalMap;
	uniform sampler2D diffuseMap;
	uniform sampler2D specularMap;
	uniform float bumpiness;
	uniform float roughness;

	uniform vec3 cubeMapSize;
	const vec3 cubeMapPos = vec3( 0, 0., 0 );

	vec3 gamma(vec3 color){
		return pow(color, vec3(1.0/2.0));
	}
	vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {

		vec3 nDir = normalize(v);
		vec3 rbmax = (   .5 * ( cubeSize - cubePos ) - pos ) / nDir;
		vec3 rbmin = ( - .5 * ( cubeSize - cubePos ) - pos ) / nDir;

		vec3 rbminmax;
		rbminmax.x = ( nDir.x > 0. )?rbmax.x:rbmin.x;
		rbminmax.y = ( nDir.y > 0. )?rbmax.y:rbmin.y;
		rbminmax.z = ( nDir.z > 0. )?rbmax.z:rbmin.z;

		float correction = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
		vec3 boxIntersection = pos + nDir * correction;

		return boxIntersection - cubePos;
	}

	vec3 r( vec3 I, vec3 N ) {

		return I - 2.0 * dot(N, I) * N;

	}

	void main()  {

		vec3 vVec = normalize( view );

		vec4 bumpNormal;
		vec3 nVec;

		bumpNormal = mix( texture2D( normalMap, vUv ), texture2D( detailNormalMap, 50. * vUv ), .5 );
		vec3 n = bumpNormal.rgb * 2.0 - 1.0;
		vec3 modifiedTangent = normalize( vec3( n.xy * bumpiness, sqrt( 1. - n.y * n.y - n.x * n.x ) ) );
		nVec = tbnMatrix * modifiedTangent;

		vec3 rVec = parallaxCorrectNormal( r( vVec, nVec ), cubeMapSize, cubeMapPos );
		#ifdef TEXTURELOD
		vec3 env = textureCubeLodEXT( envMap, rVec ).rgb;
		#else
		vec3 env = textureCube( envMap, rVec ).rgb;
		#endif

		float rim = 1. - abs( dot( nVec, vVec) );

		vec3 diffuse = texture2D( diffuseMap, vUv ).rgb;
		vec3 specular = texture2D( specularMap, vUv ).rgb;
		float r = clamp( specular.r + .2 * rim, 0., 1. );
		vec3 base = mix( diffuse, env, r );

		gl_FragColor = vec4( base, 1. );
	}

	</script>

<!-- FRAGMENT SHADER END -->


<!-- TEST VERTEX SHADER BEGIN --> 

	<script type="x-shader/x-vertex" id="vertexTestShader">

		attribute vec4 tangent;
		varying vec3 pos, view;
		varying mat3 tbnMatrix;
		varying vec2 vUv;
		uniform vec2 repeatUV;

		mat3 m3( mat4 mIn ) {

		    mat3 mOut;
		    
		    mOut[ 0 ][ 0 ] = mIn[ 0 ][ 0 ]; 
		    mOut[ 0 ][ 1 ] = mIn[ 0 ][ 1 ]; 
		    mOut[ 0 ][ 2 ] = mIn[ 0 ][ 2 ]; 
		 
		    mOut[ 1 ][ 0 ] = mIn[ 1 ][ 0 ]; 
		    mOut[ 1 ][ 1 ] = mIn[ 1 ][ 1 ]; 
		    mOut[ 1 ][ 2 ] = mIn[ 1 ][ 2 ]; 
		     
		    mOut[ 2 ][ 0 ] = mIn[ 2 ][ 0 ]; 
		    mOut[ 2 ][ 1 ] = mIn[ 2 ][ 1 ]; 
		    mOut[ 2 ][ 2 ] = mIn[ 2 ][ 2 ]; 
		    
		    return mOut;
		}

		void main()  {

		    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		    pos = vec3(modelMatrix * vec4( position, 1. ) );  

		    vec3 correctedTangent = m3( modelMatrix ) * tangent.xyz;
		    vec3 binormal = m3( modelMatrix ) * cross(normal, correctedTangent.xyz );
		    vec3 normal = m3( modelMatrix ) * normal; 
		    
		    tbnMatrix = mat3( normalize( correctedTangent ), normalize( binormal ), normalize( normal ) );
		         
		    view = pos - cameraPosition;

		    vUv = uv * repeatUV;
		}

	</script>

<!-- TEST VERTEX SHADER END --> 


<!-- TEST FRAGMENT SHADER BEGIN -->

	<script type="x-shader/x-vertex" id="fragmentTestShader">

		varying vec3 pos, view;
		varying vec2 vUv;
		varying mat3 tbnMatrix;
		uniform samplerCube envMap;
		uniform sampler2D normalMap;
		uniform sampler2D diffuseMap;
		uniform sampler2D specularMap;
		uniform float bumpiness;

		const vec3 cubeMapSize = vec3( 200., 100., 300. ) - vec3( 5. );
		const vec3 cubeMapPos = vec3( 0., 0., 0. ); 

		vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {

		    vec3 nDir = normalize(v);
		    vec3 rbmax = (   .5 * ( cubeSize - cubePos ) - pos ) / nDir;
		    vec3 rbmin = ( - .5 * ( cubeSize - cubePos ) - pos ) / nDir;
		    
		    vec3 rbminmax;
		    rbminmax.x = ( nDir.x > 0. )?rbmax.x:rbmin.x;
		    rbminmax.y = ( nDir.y > 0. )?rbmax.y:rbmin.y;
		    rbminmax.z = ( nDir.z > 0. )?rbmax.z:rbmin.z;

		    float correction = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
		    vec3 boxIntersection = pos + nDir * correction;
		    
		    return boxIntersection - cubePos;
		}

		void main()  {

		    vec3 vVec = normalize( view );  

		    vec4 bumpNormal = texture2D( normalMap, vUv );  

		    vec3 n = bumpNormal.rgb * 2.0 - 1.0;
		    vec3 modifiedTangent = normalize( vec3( n.xy * bumpiness, sqrt( 1. - n.y * n.y - n.x * n.x ) ) );
		    vec3 nVec = tbnMatrix * modifiedTangent;
		      
		    vec3 rVec = parallaxCorrectNormal( reflect( vVec, nVec ), cubeMapSize, cubeMapPos );
		    vec3 env = textureCube( envMap, rVec ).rgb;

		    vec3 diffuse = texture2D( diffuseMap, vUv ).rgb;
		    vec3 specular = texture2D( specularMap, vUv ).rgb;
		    
		    vec3 dN = parallaxCorrectNormal( nVec, cubeMapSize, cubeMapPos ).rgb;
		    vec4 diffuseColor = ( 2. / sqrt( length( dN ) ) ) *  textureCube( envMap, dN );
		    
		    gl_FragColor = vec4( diffuse, 1. );

		}

	</script> 

<!-- TEST FRAGMENT SHADER END -->


<!-- SIMPLE VERTEX SHADER BEGIN --> 
	<script type="x-shader/x-vertex" id="simpleVertexShader">

		varying vec2 vUv;

		void main() {

		    vUv = uv;
		    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	</script>

<!-- SIMPLE VERTEX SHADER END --> 


<!-- SIMPLE FRAGMENT SHADER BEGIN --> 

	<script type="x-shader/x-vertex" id="simpleFragmentShader">

		varying vec2 vUv;

		void main() {

		    // colour is RGBA: u, v, 0, 1
		    gl_FragColor = vec4( vec3( vUv, 0. ), 1. );

		}

	</script>

<!-- SIMPLE FRAGMENT SHADER END --> 


<script>

	var container, controls, loader;
	var camera, scene, renderer;
	var cubeCamera, baseMaterial, diffuseTexture;
	var mSphere, cubeMapFlatView;
	var initMaterial, flatMaterial, shinyMaterial;

	var diffuseTexture, normalTexture, specularTexture, displacementTexture;

	init();

	/////////////////

	function addGeo( objName ) {

		loader = new THREE.OBJLoader();
		loader.load( "geo/" + objName + ".obj", function ( object ) {

			loader = new THREE.TextureLoader();
			flatMaterial = new THREE.MeshBasicMaterial( { } );
			flatMaterial.map = loader.load( "img/" + objName + "_blur.jpg",
										function (texture) {
											ready();
										} );

			var glMaterial = new THREE.MeshBasicMaterial();
			glMaterial.map = flatMaterial.map
			
		    object.traverse( function ( child ) {

		        if ( child instanceof THREE.Mesh ) {
		            child.material = shinyMaterial;
		        }

		    } );
			scene.add( object );
		} );

	}

	/////////////////

	function init() {

		container = document.createElement( "div" );
		document.body.appendChild( container );

		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 1000 );
		camera.position.set( 3, 0.75, 0 );
		scene.add( camera );

		renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );
		controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls.center = new THREE.Vector3(0, 1.25, 1);

		function prepare() {

			// Create Skybox
			var skyBoxGeometry = new THREE.CubeGeometry( 100, 100, 100 );
			var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.BackSide } );
			var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
			scene.add( skyBox );

			// Load Geometry
			var ceiling = addGeo( "ceiling" );
			var walls = addGeo( "walls" );
			var floor = addGeo( "floor" );

			// Create CubeCamera
			cubeCamera = new THREE.CubeCamera( 0.00000001, 10, 256 );
			cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
			cubeCamera.position.set( 0, 1, 0 );
			scene.add( cubeCamera );

			///////////////////
			var fragmentPrefix = '';

			shinyMaterial = new THREE.ShaderMaterial( {
				uniforms: {
					bumpiness: { type: 'f', value: 1 },
					repeatUV: { type: 'v2', value: new THREE.Vector2( 1, 1 ) },
					diffuseMap: { type: 't', value: diffuseTexture },
					specularMap: { type: 't', value: specularTexture },
					normalMap: { type: 't', value: normalTexture },
					detailNormalMap: { type: 't', value: displacementTexture },
					envMap: { type: 't', value: cubeCamera.renderTarget },
					specular: { type: 'f', value: 0 },
					roughness: { type: 'f', value: 2 },
					cubeMapSize: { type: 'v3', value: new THREE.Vector3() }
				},
				vertexShader: document.getElementById( 'vertexTestShader' ).textContent,
				fragmentShader: fragmentPrefix + document.getElementById( 'fragmentTestShader' ).textContent
			} );

			// Display CubeMap
			var mSphereGeo =  new THREE.SphereGeometry( 0.25, 32, 32 );
			var mSphereMat = new THREE.MeshBasicMaterial( { envMap: cubeCamera.renderTarget.texture } );
			mSphere = new THREE.Mesh( mSphereGeo, mSphereMat );
			var mSpherePos = new THREE.Vector3( -0.75, 1, 0.75 );
			mSphere.position.copy( mSpherePos );
			scene.add(mSphere);
			cubeMapFlatView = new THREE.CubeMapFlatView( cubeCamera.renderTarget.texture, 128, 5, 5 );

		}

		var t = new THREE.TextureLoader();
		t.load( 'img/diffuse_map.jpg', function( t ) { diffuseTexture = t; } );
		t.load( 'img/specular_map.jpg', function( t ) { specularTexture = t; } );
		t.load( 'img/normal_map.png', function( t ) { normalTexture = t; } );
		t.load( 'img/displacement_map.jpg', function( t ) { displacementTexture = t; } );

		prepare();

	}

	// Ready & Render

	function ready() {

		mSphere.visible = false;
		scene.overrideMaterial = flatMaterial;
		cubeCamera.updateCubeMap( renderer, scene );
		scene.overrideMaterial = null;
		mSphere.visible = true;
		render();

	}

	function render() {

		requestAnimationFrame( render );
		controls.update();
		renderer.render( scene, camera );
		cubeMapFlatView.render( renderer );

	}

</script>
</body>
</html>