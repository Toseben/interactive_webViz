<script>

	function selectQuality() {

		var links = document.querySelectorAll( 'div ul li' );
		[].forEach.call( links, function( li ) {
			var url = li.getAttribute( 'data-url' );
			li.addEventListener( 'click', function( e ) {
				var hashFields = url.split( '&' );
				hashFields.forEach( function( e ) {
					var f = e.split( '=' );
					var obj = {}
					hashOptions[ f [ 0 ] ] = f[ 1 ] == 'true'?true:false;
				} );
				document.getElementById( 'selection' ).classList.add( 'hidden' );
				init();
				e.preventDefault();
			} );
		} );

	}

	function goInteractive() {

		manual = true;
		controls = new THREE.OrbitControls( camera );
		sphere.visible = true;
		sphere.scale.set( .2, .2, .2 );
		vignettePass.params.boost = 2;

	}

	function init() {

		document.getElementById( 'headphones' ).style.opacity = 1;

		if( hashOptions.dof != undefined ) dof = hashOptions.dof;

		scene = new THREE.Scene();
		var aspectRatio = window.innerWidth / window.innerHeight;
		camera = new THREE.PerspectiveCamera( 45, aspectRatio, .01, 30 );
		camera.target = new THREE.Vector3();

		if( manual ) {
			controls = new THREE.OrbitControls( camera );
			controls.damping = 0.2;
		}

		renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false });
		document.body.appendChild( renderer.domElement );
		var pixelRatioScale = isMobile?.5:1;
		if( hashOptions.scale != undefined ) pixelRatioScale = hashOptions.scale?.5:1;
		renderer.setPixelRatio( pixelRatioScale * window.devicePixelRatio );
		renderer.setClearColor( 0xffffff, 1. );
		renderer.autoClear = false;

		var textureLOD = null;//renderer.context.getExtension( 'EXT_shader_texture_lod' );

		var fragmentPrefix = '';
		if( textureLOD ) fragmentPrefix = '#define TEXTURELOD';

		composer = new WAGNER.Composer( renderer, { useRGBA: false } );
		vignettePass = new WAGNER.Vignette2Pass();
		vignettePass.params.reduction = 2;
		FXAAPass = new WAGNER.FXAAPass();
		var bufferSize = isMobile?256:512;
		bloomPass = new WAGNER.MultiPassBloomPass( bufferSize, bufferSize );
		bloomPass.params.blurAmount = isMobile?.5:1;
		DOFPass = new WAGNER.DOFPass();
		//DOFPass = new WAGNER.BokehPoisonPass();
		noisePass = new WAGNER.NoisePass();

		noisePass.params.amount = .01;

		rgbSplitPass = new WAGNER.RGBSplitPass();
		rgbSplitPass.params.delta.set( pixelRatioScale * 20, pixelRatioScale * 20 );

		bokehPass = new WAGNER.BokehPoisonPass();

		bleachPass = new WAGNER.BleachPass();

		DOFPass.params.aperture = .01;

		cubeCamera = new THREE.CubeCamera( .00000001, 10, 1024 ); // parameters: near, far, resolution
		cubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter; // mipmap filter
		cubeCamera.position.set( 0, 0, 0 );
		scene.add( cubeCamera );

		window.addEventListener( 'resize', onWindowResize );

		var sL = new ShaderLoader()
		sL.add( 'depth-vs', 'bower_components/Wagner/vertex-shaders/packed-depth-vs.glsl' );
		sL.add( 'depth-fs', 'bower_components/Wagner/fragment-shaders/packed-depth-fs.glsl' );
		sL.load();
		sL.onLoaded( function() {
			depthMaterial = new THREE.ShaderMaterial( {
				uniforms: {
					mNear: { type: 'f', value: camera.near },
					mFar: { type: 'f', value: camera.far }
				},
				vertexShader: this.get( 'depth-vs' ),
				fragmentShader: this.get( 'depth-fs' ),
				shading: THREE.SmoothShading
			} );
		} );

		var diffuseTexture, normalTexture, specularTexture, displacementTexture;
		var diffuseOrbTexture, normalOrbTexture, specularOrbTexture, lightOrbTexture;

		onWindowResize();

		function prepare() {

			scene.add( roomModel );

			shinyMaterial = new THREE.ShaderMaterial( {
				uniforms: {
					bumpiness: { type: 'f', value: 1 },
					repeatUV: { type: 'v2', value: new THREE.Vector2( 1, 1 ) },
					diffuseMap: { type: 't', value: diffuseTexture },
					specularMap: { type: 't', value: specularTexture },
					normalMap: { type: 't', value: normalTexture },
					detailNormalMap: { type: 't', value: displacementTexture },
					envMap: { type: 't', value: cubeCamera.renderTarget },
					specular: { type: 'f', value: 0 },
					roughness: { type: 'f', value: 2 },
					cubeMapSize: { type: 'v3', value: new THREE.Vector3() }
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: fragmentPrefix + document.getElementById( 'fragmentShader' ).textContent,
				side: THREE.FrontSide
			} );

			shinyMaterial.uniforms.normalMap.value.wrapS =
			shinyMaterial.uniforms.normalMap.value.wrapT =
			shinyMaterial.uniforms.detailNormalMap.value.wrapS =
			shinyMaterial.uniforms.detailNormalMap.value.wrapT =
			shinyMaterial.uniforms.diffuseMap.value.wrapS =
			shinyMaterial.uniforms.diffuseMap.value.wrapT =
			shinyMaterial.uniforms.specularMap.value.wrapS =
			shinyMaterial.uniforms.specularMap.value.wrapT =
			THREE.RepeatWrapping;

			progressIndicator( 91 );

			baseMaterial = new THREE.MeshBasicMaterial( { map: diffuseTexture } );
			var height = 4;

			roomModel.children.forEach( function( e ) {
				e.geometry.center();

				var indices_array = [];
				for( var j = 0; j < e.geometry.attributes.position.array.length / 3; j++ ){
					indices_array.push( j );
				}

				e.geometry.setIndex( new THREE.BufferAttribute( new Uint16Array( indices_array ), 1 ) );

				THREE.BufferGeometryUtils.computeTangents( e.geometry );
				var t = e.geometry.boundingBox.max.clone();
				t.sub( e.geometry.boundingBox.min );
				scale = height / t.y;

				e.scale.set( scale, scale, scale );
				e.material = shinyMaterial;
				t.multiply( e.scale );
				e.material.uniforms.cubeMapSize.value.copy( t )
			} );

			progressIndicator( 92 );

			var m = new THREE.ShaderMaterial( {
				uniforms: {
					bumpiness: { type: 'f', value: 1 },
					repeatUV: { type: 'v2', value: new THREE.Vector2( 1, 1 ) },
					normalMap: { type: 't', value: normalOrbTexture },
					detailNormalMap: { type: 't', value: displacementTexture },
					envMap: { type: 't', value: cubeCamera.renderTarget }
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: fragmentPrefix + document.getElementById( 'fragment2Shader' ).textContent,
				side: THREE.DoubleSide
			} );

			m.uniforms.normalMap.value.wrapS =
			m.uniforms.normalMap.value.wrapT =
			m.uniforms.detailNormalMap.value.wrapS =
			m.uniforms.detailNormalMap.value.wrapT =
			THREE.RepeatWrapping;

			progressIndicator( 93 );

			var geometry = cubeModel.children[ 0 ].geometry;

			var indices_array = [];
			for( var j = 0; j < geometry.attributes.position.array.length / 3; j++ ){
				indices_array.push( j );
			}

			geometry.setIndex( new THREE.BufferAttribute( new Uint16Array( indices_array ), 1 ) );

			//geometry.computeFaceNormals();
			//geometry.computeVertexNormals();
			THREE.BufferGeometryUtils.computeTangents( geometry );
			geometry.center();

			progressIndicator( 94 );

			sphere = new THREE.Mesh( geometry, m );
			scene.add( sphere );
			sphere.position.x = -4 * scale;
			sphere.scale.set( .25 * scale, .25 * scale, .25 * scale );

			progressIndicator( 95 );

			camera.position.set( 8.48048079936136, -2.086495492733194, 0.3702657880176793 );
			camera.position.multiplyScalar( scale );
			camera.lookAt( sphere.position );

			ready();
		}

		function ready() {

			scene.overrideMaterial = baseMaterial;
			sphere.visible = false;
			cubeCamera.updateCubeMap( renderer, scene );
			scene.overrideMaterial = null;
			cubeMapGenerated = true;
			sphere.visible = true;

			progressIndicator( 96 );

			renderer.domElement.style.display = 'none';
			renderer.render(scene, camera );
			renderer.setClearColor( 0, 1. );
			renderer.clear();
			renderer.setClearColor( 0xffffff, 1. );
			renderer.domElement.style.display = 'block';

			progressIndicator( 100 );

			function startAudio() {

				tapToStart.removeEventListener( 'click', startAudio );
				tapToStart.classList.add( 'hidden' );

				audio.addEventListener( 'canplay', function() {
					startTime = Date.now();
					if( !manual ) audio.play();
					startRendering();
				} )
				if( !useAudio ) audio.volume = 0;
				audio.preload = 'auto';
				audio.autoplay = false;
				audio.src = 'assets/track.mp3';
				audio.play();

			}

			if( isMobile ) {
				tapToStart.classList.remove( 'hidden' );
				tapToStart.addEventListener( 'click', startAudio );
			} else {
				startAudio();
			}

			document.getElementById( 'progress' ).style.opacity = 0;

		}

		function startRendering() {

			( function attachInteractiveModeTrigger() {
				var count = 0;
				document.body.addEventListener( 'click', function() {
					count++;
					if( count == 3 ) goInteractive();
				} );
				document.body.addEventListener( 'touchend', function() {
					count++;
					if( count == 3 ) goInteractive();
				} );
			} )();

			document.getElementById( 'headphones' ).style.opacity = 0;
			setTimeout( render, 1000 );

		}

		var l = new THREE.LoadingManager(
			function() { console.log( 'onLoad' ); prepare(); },
			function( item, loaded, total ) {
				progressIndicator( loaded * 90 / total )
			},
			function() { console.log( 'onError' ) }
			);
		var t = new THREE.TextureLoader( l );

		var res = '4096';
		t.load( 'assets/baked_' + res + '.jpg', function( t ) { diffuseTexture = t; } );
		t.load( 'assets/spec_' + res + '.jpg', function( t ) { specularTexture = t; } );
		t.load( 'assets/norm_' + res + '.jpg', function( t ) { normalTexture = t; } );

		t.load( 'assets/displacement.jpg', function( t ) { displacementTexture = t; } );

		t.load( 'assets/orb-norm.png', function( t ) { normalOrbTexture = t; } );

		var m = new THREE.OBJLoader( l );
		m.load( 'assets/hall.obj', function( m ) { roomModel = m; } );
		m.load( 'assets/orb.obj', function( m ) { cubeModel = m; } );

	}

	function updateStory( t ) {

		camera.position.x = averageData( storyline, t, 'x' ) * scale;
		camera.position.y = averageData( storyline, t, 'y' ) * scale;
		camera.position.z = averageData( storyline, t, 'z' ) * scale;

		camera.target.x = averageData( storyline, t, 'targetx' ) * scale;
		camera.target.y = averageData( storyline, t, 'targety' ) * scale;
		camera.target.z = averageData( storyline, t, 'targetz' ) * scale;

		camera.lookAt( camera.target );

		//vignettePass.params.reduction = 3 + ( 10 - 10 * averageData( storyline, t, 'fade' ) );
		vignettePass.params.boost = 2 * averageData( storyline, t, 'fade' );
		vignettePass.params.boost += .2 * iNoise.noise( t, .234234, .565 );

		var s = .2 * averageData( storyline, t, 'sphere' ) * scale;
		sphere.scale.set( s, s, s );
		sphere.visible = s > .001;

		sphere.position.x = averageData( storyline, t, 'orbx' ) * scale;

		sphere.rotation.y = averageData( storyline, t, 'sphereAngle' );

		intro.style.opacity = averageData( storyline, t, 'text' );
		credits.style.opacity = averageData( storyline, t, 'credits' );

		var fov = averageData( storyline, t, 'fov' );
		if( fov != camera.fov ) {
			camera.fov = fov;
			camera.updateProjectionMatrix();
		}

		DOFPass.params.aperture = averageData( storyline, t, 'aperture' ) * scale;
		DOFPass.params.autofocus = averageData( storyline, t, 'autofocus' );
		DOFPass.params.fD = averageData( storyline, t, 'focalDistance' );

		if( t > 120 ) credits.style.pointerEvents = 'auto';

	}

	function render() {

		requestAnimationFrame(render);

		if( !manual ){
			var t = .001 * ( Date.now() - startTime );
			if( useAudio ) t = audio.currentTime;
			updateStory( t );
		}

		if( hashOptions.post == false ) {
			renderer.setClearColor( 0xffffff );
			renderer.render( scene, camera );
			return;
		}

		composer.reset();

		if( ( dof && DOFPass.params.aperture > 0 ) || bokeh ) {
			scene.overrideMaterial = depthMaterial;
			composer.render( scene, camera, null, depthTexture );
			DOFPass.params.tBias = depthTexture;
			bokehPass.params.tBias = depthTexture;

			scene.overrideMaterial = null;
			composer.render( scene, camera );
		} else {
			composer.render( scene, camera );
		}

		if( vignette ) composer.pass( vignettePass );

		if( rgbSplit ) composer.pass( rgbSplitPass );

		if( ( dof && DOFPass.params.aperture > 0 ) ) {
			if( DOFPass.params.autofocus ) {
				raycaster.setFromCamera( centerVector, camera );
				var intersects = raycaster.intersectObjects( [ sphere, roomModel ], true );
				if( intersects.length ) {
					DOFPass.params.focalDistance = 1 - intersects[ 0 ].distance / ( camera.far - camera.near );
				}
			} else {
				DOFPass.params.focalDistance = DOFPass.params.fD;
			}
			composer.pass( DOFPass );
		}

		if( bloom ) composer.pass( bloomPass );

		if( fxaa ) composer.pass( FXAAPass );

		if( bokeh ) composer.pass( bokehPass );

		if( bleach ) composer.pass( bleachPass );

		if( noise ) composer.pass( noisePass );

		composer.toScreen();

	}

	function onWindowResize() {

		renderer.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		composer.setSize( renderer.domElement.width, renderer.domElement.height );
		depthTexture = WAGNER.Pass.prototype.getOfflineTexture( composer.width, composer.height, false );

	}

</script>